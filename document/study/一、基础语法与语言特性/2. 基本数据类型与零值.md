# 基本数据类型与零值  

## Go 中的类型大致分层次

在 Go 里，常说的「基本数据类型」通常指内置的标量类型：

- 布尔型：`bool`；  
- 整型：`int`、`int8`、`int16`、`int32`、`int64` 以及对应的无符号整型；  
- 浮点型：`float32`、`float64`；  
- 复数型：`complex64`、`complex128`；  
- 字符串：`string`；  

另外还有两个非常常用的**预定义别名类型**：

- `byte`：`uint8` 的别名，通常表示原始字节数据；  
- `rune`：`int32` 的别名，通常表示一个 Unicode 码点（字符）；  

除了这些，还有数组、切片、结构体、映射、函数、接口、指针、通道等**复合/引用类型**，本节先给一个整体概览，后续章节再分别展开。  

### 复合/引用类型总览

- 数组（array）：长度固定、元素类型相同的序列，类型的一部分是长度，例如 `[3]int` 和 `[4]int` 是两种不同的类型；  
- 切片（slice）：对底层数组的一段「动态视图」，包含指针、长度和容量，是日常最常用的序列类型；  
- 结构体（struct）：由多个字段组合而成的自定义类型，是建模业务实体的基础；  
- 映射（map）：键值对集合，键可以是可比较类型，底层通常用哈希表实现；  
- 函数类型（func）：函数也是一等公民，可以作为参数、返回值或变量保存；  
- 接口（interface）：定义一组方法集合，类型只要实现这些方法就隐式满足该接口；  
- 指针（*T）：保存某个值在内存中的地址，用于间接访问和共享数据；  
- 通道（chan T）：用于在 goroutine 之间传递数据的同步原语，是 Go 并发模型的核心之一；  

在零值方面，需要特别记住：

- 数组和结构体的零值是「所有元素/字段都是对应类型的零值」；  
- 切片、映射、函数、指针、通道、接口的零值都是 `nil`，在使用前通常需要显式初始化（例如 `make` 或 `new`）；  

## 布尔型（bool）

- 取值只有两个：`true`、`false`；  
- 零值：`false`；  
- 常用场景：条件判断、循环控制等；  

示例：

```go
var ok bool        // 零值为 false
ok = true
if ok {
    // ...
}
```

## 整型（int / uint 系列）

### 有符号整型

- `int8`：范围 `-128` 到 `127`；  
- `int16`：范围 `-32768` 到 `32767`；  
- `int32`：通常等价于 C 语言中的 `int`（32 位）；  
- `int64`：64 位有符号整数；  
- `int`：在 32 位架构上等价于 `int32`，在 64 位架构上等价于 `int64`；  

日常编码中，**优先使用 `int`** 来表示计数、长度、索引等，一般不需要刻意选择具体位数，除非是二进制协议、文件格式等对位宽有严格要求的场景。  

### 无符号整型

- `uint8`、`uint16`、`uint32`、`uint64`：对应位数的无符号整数；  
- `uint`：与 `int` 类似，位数与架构相关（32 或 64 位）；  
- `uintptr`：足以容纳一个指针的无符号整数，多用于底层场景；  

关于 `uintptr` 需要单独记一下：

- 它的位宽刚好能装下一个指针值（例如 64 位架构上通常是 64 位）；  
- 它本质上是一个「普通整数」，**不是指针类型**；  
- 通常配合 `unsafe.Pointer` 做指针地址运算，例如字段偏移计算；  
- 一旦把指针转换成 `uintptr`，垃圾回收器就不会再把这个值当作指针来追踪引用；  

典型用法是做短暂的地址偏移运算，然后马上再转回真正的指针类型，例如：

```go
type Node struct {
    Value int32
    Next  *Node
}

// 通过 uintptr 做字段偏移，拿到 Value 字段的地址
func valuePtr(n *Node) *int32 {
    return (*int32)(unsafe.Pointer(
        uintptr(unsafe.Pointer(n)) + unsafe.Sizeof(n.Next),
    ))
}
```

注意这类用法只应出现在偏底层、对内存布局有明确要求的地方，普通业务代码里几乎不需要使用 `uintptr`。  

预定义别名：

- `byte`：`uint8` 的别名，用于强调「这是一个字节」而不是一般的数字；  

零值：

- 所有整型（包括 `int`、`uint`、`byte` 等）的零值都是 `0`。  

示例：

```go
var a int        // 0
var b int64      // 0
var c byte       // 0
var d uintptr    // 0
```

## 浮点型（float32 / float64）

- `float32`：32 位浮点数，大约 6 位十进制有效数字；  
- `float64`：64 位浮点数，大约 15 位十进制有效数字，**默认推荐使用**；  
- 零值：`0`（表现为 `0` 或 `0.0`）；  

示例：

```go
var f32 float32    // 0
var f64 float64    // 0
price := 19.99     // 默认是 float64
```

### 为什么浮点数是「近似值」

Go 中的 `float32` 和 `float64` 底层使用 IEEE 754 标准的二进制浮点表示，本质上是用「符号位 + 指数 + 尾数」在有限的二进制位里近似表示实数：

- 一个浮点数大致可以看成：`(-1)^sign × 1.fraction × 2^exponent`；  
- `fraction` 只有有限位，比如 `float64` 的有效位大约 15 位十进制有效数字；  

这会带来两个直接后果：

- 绝大部分十进制小数都不能被二进制精确表示（比如 `0.1`、`0.2`、`0.3` 等）；  
- 这些数会被「取整」到最接近的可表示二进制小数上，只是这个差异非常小；  

典型例子：

```go
f := 0.1 + 0.2
fmt.Println(f == 0.3)   // 可能是 false
fmt.Println(f)          // 打印出像 0.30000000000000004 之类的结果
```

从底层看，`0.1` 和 `0.2` 对应的二进制形式都是无限循环小数，只能截断成有限位，因此累加后的结果和十进制的 `0.3` 会有细微误差。  

在大量运算（比如循环累加、金融计算）中，这种微小误差还会不断累积，所以：

- 浮点数更适合作为近似表示的「测量值」「计算结果」；  
- 对浮点数相等性判断时，通常使用一个误差范围（epsilon）而不是直接用 `==`；  

简单的误差判断方式可以写成：

```go
const eps = 1e-9
if math.Abs(f1-f2) < eps {
    // 认为 f1 和 f2 在可接受的误差范围内相等
}
```

理解这一点有助于你在设计接口和数据结构时，避免用 `float64` 做 map 键或严格比较逻辑，而是只在需要近似计算的场景中使用浮点数。  

## 复数类型（complex64 / complex128）

- `complex64`：实部和虚部都是 `float32`；  
- `complex128`：实部和虚部都是 `float64`；  
- 零值：`0 + 0i`（可以直接写成 `0`）；  

示例：

```go
var z complex128          // 0 + 0i
z = complex(1.5, -2.3)    // 1.5 - 2.3i
```

复数在一般业务代码中使用较少，但在某些数学、信号处理领域会用到。  

## 字符与字符串（rune / byte / string）

### 字符串 string

- 字符串是一个**只读的字节序列**，默认采用 UTF-8 编码；  
- 零值：空字符串 `""`；  
- 一旦创建不可修改，对字符串的「修改」通常通过构造新字符串实现；  

在实现上，可以把字符串大致理解成：

```go
type string struct {
    data *byte // 指向一段只读字节数据
    len  int   // 长度（字节数）
}
```

几个重要结论：

- 多个字符串值可以共享同一段底层字节数据，只读设计保证这种共享是安全的；  
- Go 从语法上禁止修改字符串内容，例如 `s[0] = 'H'` 会直接编译错误；  
- 所谓「修改字符串」，本质都是：在别处构造新的字节序列，然后生成一个新的 `string` 值；  

常见的修改方式都是围绕「构造新字符串」展开的：

- 先把字符串转成可变的 `[]byte` 或 `[]rune`，在切片上修改，再转回 `string`；  
- 使用拼接表达式 `s = s + "..."`，底层会创建新的字符串；  
- 使用 `strings.Builder` 或 `bytes.Buffer` 累积写入，最后一次性调用 `String()` 得到结果；  

示例（通过 `[]rune` 修改第一个字符，更适合包含中文等多字节字符的场景）：

```go
s := "hello"
r := []rune(s)
r[0] = '你'
s2 := string(r)  // "你ello"
```

通过不可变设计，字符串在跨 goroutine 共享、作为 map 键、作为常量使用时都更加安全可靠。  

示例：

```go
var s string     // 零值为 ""
s = "hello"
```

### 字节 byte

- `byte` 是 `uint8` 的别名，常用于表示原始二进制数据；  
- 字符串与 `[]byte` 可以相互转换：  

```go
s := "hello"
b := []byte(s)      // 字符串转字节切片
s2 := string(b)     // 字节切片转字符串
```

### 字符 rune

- `rune` 是 `int32` 的别名，表示一个 Unicode 码点；  
- 使用 `for range` 遍历字符串时，遍历到的就是 `rune`；  

```go
s := "你好"
for _, ch := range s {
    // ch 的类型是 rune，对应一个完整的中文字符
}
```

注意：`len(s)` 返回的是字节数，不一定等于字符数（特别是包含中文或 emoji 时）。  

## 复合类型详解（数组、切片、结构体、映射等）

### 数组（array）

- 定义：长度固定、元素类型相同，长度是类型的一部分，例如 `[3]int` 和 `[4]int` 是不同类型；  
- 零值：所有元素都是对应元素类型的零值；  
- 赋值和传参时是值拷贝；  

示例：

```go
var a [3]int
b := [3]int{1, 2, 3}
c := [...]string{"a", "b", "c"}
```

数组的几种常见定义方式可以归纳为：

- 只声明（使用零值）：`var a [3]int`；  
- 显式写长度的字面量：`b := [3]int{1, 2, 3}`；  
- 使用 `...` 让编译器推断长度：`c := [...]string{"a", "b", "c"}`（推断为 `[3]string`）；  
- 按索引指定元素（适合稀疏初始化）：`d := [5]int{0: 10, 3: 20}`（得到 `[10 0 0 20 0]`）；  

注意几点：

- 数组类型是值类型，赋值或作为参数传递时会整体拷贝一份；  
- 数组是固定长度的，不能使用 `make` 来创建，`make` 只用于切片、映射和通道；  
- 实际开发中，数组常作为底层存储，日常业务更多直接使用切片 `[]T`；  

数组适合用在长度已知且较小、需要严格值语义的场景，在日常代码中更常见的是基于数组的切片。  

### 切片（slice）

- 切片是对底层数组的一段「视图」，包含指向数组的指针、长度和容量；  
- 零值是 `nil`，`len` 和 `cap` 都为 0；  
- 多个切片可以共享同一个底层数组，对一个切片元素的修改可能影响到另一个切片；  

创建切片的常见方式：

```go
s1 := []int{1, 2, 3}
s2 := make([]int, 0, 10)
s3 := s1[1:3]
```

追加元素使用 `append`，可能触发底层数组扩容并返回新的切片值：  

```go
s1 = append(s1, 4)
```

### 结构体（struct）

- 将多个字段组合成一个新的自定义类型，用于表达业务实体；  
- 字段可以是任意类型，也可以嵌套其他结构体；  
- 零值是各字段分别取零值；  

示例：

```go
type User struct {
    ID   int64
    Name string
}

var u User
u2 := User{ID: 1, Name: "Alice"}
```

结构体既可以按值传递，也可以通过指针共享和修改。  

### 映射（map）

- 无序的键值对集合，键类型必须是可比较类型；  
- 底层通常是哈希表实现；  
- 零值是 `nil`，只能读取不能写入；  

创建和使用：

```go
m := make(map[string]int)
m["alice"] = 10
v, ok := m["bob"]
```

读取不存在的键会返回该值类型的零值，第二个返回值可以判断键是否存在。  

### 函数类型（func）

- 函数在 Go 中是一等公民，可以保存到变量中、作为参数或返回值；  
- 函数类型由参数列表和返回值列表共同决定；  
- 零值是 `nil`，调用前需要确保不为 `nil`；  

示例：

```go
var f func(int) int
f = func(x int) int { return x * 2 }
result := f(10)
```

函数类型为后续的回调、装饰器、高阶函数等提供基础。  

### 接口类型（interface）

- 接口定义了一组方法集合，类型只要实现这些方法就隐式满足该接口；  
- 接口值在运行时包含动态类型和值两部分；  
- 零值是 `nil`，表示没有动态类型和值；  

示例：

```go
type Reader interface {
    Read(p []byte) (n int, err error)
}
```

接口是 Go 实现多态和抽象的核心机制。  

### 指针（*T）

- 保存某个值在内存中的地址，可以通过解引用间接读写该值；  
- 零值是 `nil`，表示不指向任何有效地址；  

示例：

```go
var p *int
x := 10
p = &x
y := *p
```

与值拷贝相比，通过指针可以在函数间共享和修改同一份数据，需要注意避免悬空指针和数据竞争。  

### 通道（chan T）

- 用于在 goroutine 之间传递数据，是 Go 并发模型的重要组成部分；  
- 可以分为无缓冲和有缓冲通道；  
- 零值是 `nil`，发送和接收操作会永久阻塞；  

创建通道并发送接收数据：

```go
ch := make(chan int)
go func() {
    ch <- 1
}()
v := <-ch
```

在后续并发章节会对通道的关闭规则、缓冲行为和 select 语法做更详细的讲解。  

## 零值（Zero Value）总览

在 Go 中，如果只用 `var` 声明一个变量而不显式赋值，它会被自动赋予该类型的「零值」。  

常见类型的零值可以总结为：

- `bool`：`false`；  
- 整型（所有 `int` / `uint` / `byte` / `rune` 等）：`0`；  
- 浮点型（`float32` / `float64`）：`0`；  
- 复数（`complex64` / `complex128`）：`0`（即 `0 + 0i`）；  
- `string`：空字符串 `""`；  
- 数组：所有元素都是对应元素类型的零值；  
- 结构体：所有字段都是对应字段类型的零值；  
- 指针、切片、映射、函数、通道、接口：`nil`；  

示例：

```go
var (
    b   bool
    i   int
    f   float64
    s   string
    arr [3]int
    m   map[string]int
)

// b == false
// i == 0
// f == 0
// s == ""
// arr == [0 0 0]
// m == nil
```

理解零值有助于写出更简洁的 Go 代码：很多时候只需要 `var` 声明而不必手动初始化为「空」，因为 Go 已经帮你做了合理的默认初始化。  
