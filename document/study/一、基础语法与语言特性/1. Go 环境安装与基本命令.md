# Go 环境安装与基本命令  
## Go 安装与版本管理 

常见的 Go 安装方式有两种：

- 官方安装包：从 https://go.dev/dl 下载对应平台的安装包，一路下一步即可。  
  - 优点：官方推荐、比较稳定；  
  - 一般会自动把 `go` 命令加入 `PATH`。
- 包管理工具：如 macOS 上使用 `Homebrew`：  
  - `brew install go` 安装  
  - `brew upgrade go` 升级到新版本  

安装完成后，建议在终端里做一次基本检查：

- 查看版本：`go version`  
- 查看关键环境：`go env GOROOT GOPATH GOPROXY`  

版本管理的常见思路：

- 一般情况下，只保持**一个全局稳定版本**即可（例如最新的稳定版）；  
- 如果确实需要在多个版本之间切换，可以借助第三方版本管理工具（如 `asdf`, `gvm` 等），但在入门阶段并不是必须，优先把当前版本用熟即可。  
- gvm不是很稳定，最好用docker来控制

## go env 的作用 

`go env` 用来查看和管理 Go 相关的环境配置，是排查问题、确认安装是否正常时最常用的命令之一。

常见用法：

- 查看所有 Go 环境变量：`go env`  
- 只看某几个关键变量：`go env GOPATH GOROOT GOPROXY`  
- 以 JSON 格式输出（更适合脚本或查阅）：`go env -json`  

从 Go 1.13 起，可以用 `go env -w` 持久化修改某些配置（写入 Go 的配置文件），例如：

- 设置国内常用的模块代理：  
  - `go env -w GOPROXY=https://goproxy.cn,direct`  
- 取消某个通过 `-w` 设置的值：  
  - `go env -u GOPROXY`  

学习阶段可以重点关注这些变量的大致含义：

- `GOROOT`：Go 安装目录（编译器和标准库所在位置）；  
- `GOPATH`：工作空间根目录（模块缓存等默认会放在这里）；  
- `GOBIN`：可执行文件安装目录（默认是 `$GOPATH/bin`）；  
- `GOPROXY`：拉取 Go Modules 时使用的代理地址；  
- `GOMODCACHE`：模块依赖缓存目录；  

掌握 `go env` 的基本用法，可以在遇到「命令找不到」「依赖拉不下来」这类问题时，迅速确认当前环境配置是否合理。

## go run / go build / go install 的区别

这三个命令的共同点都是「先编译」，不同点在于**编译结果如何处理**：

- `go run`：临时编译并立刻运行，不保留可执行文件；  
- `go build`：编译生成可执行文件，但不安装、不自动运行；  
- `go install`：编译并把可执行文件安装到统一目录，方便全局使用；  

可以按下面的方式理解和记忆：

### go run

- 做了什么：  
  - 把指定的 Go 源码先编译成一个临时二进制；  
  - 立即运行这个二进制，退出后临时文件被删除；  
- 常见用法：  
  - `go run main.go`  
  - `go run .`（运行当前目录的 main 包）  
- 适合场景：  
  - 写 demo、小脚本、练习代码，临时跑一跑即可；  
- 关键词：**一次性运行，不关心二进制放哪**。  

### go build

- 做了什么：  
  - 编译当前包及依赖；  
  - 如果是 main 包，会在当前目录生成一个可执行文件；  
  - 如果是普通包，只做编译检查，不生成可执行文件；  
- 常见用法：  
  - `go build`（在当前目录构建可执行文件）  
  - `go build -o app .`（指定输出文件名）  
  - `go build ./cmd/server`  
- 适合场景：  
  - 本地构建要运行或发布的二进制；  
  - CI/CD 中做编译检查；  
- 关键词：**只编译，生成二进制，但不安装、不自动运行**。  

### go install

- 做了什么：  
  - 先编译 main 包；  
  - 再把生成的可执行文件安装到 `GOBIN` 或 `GOPATH/bin` 下；  
- 常见用法：  
  - `go install`（安装当前模块中的 main 包）  
  - `go install ./cmd/server`  
  - `go install example.com/tool/cmd/xxx@latest`（安装远程工具，Go 1.17+ 推荐写法）  
- 适合场景：  
  - 安装命令行工具，期望在任何目录下都能通过名字直接运行；  
- 关键词：**编译 + 安装到统一 bin 目录，方便重复使用**。  

### 三者快速对比

- `go run`：编译 + 立刻执行，不保留二进制；  
- `go build`：编译 + 生成二进制，不安装、不执行；  
- `go install`：编译 + 生成二进制并安装到 `GOBIN`/`GOPATH/bin`，不执行；  

在实际开发中，可以按习惯简单分工：

- 想「临时跑一下」用 `go run`；  
- 想「生成一个二进制自己手动运行或部署」用 `go build`；  
- 想「安装一个工具或全局命令」用 `go install`。  

## Go 程序的执行入口（main 包、main 函数）

在 Go 里，一个可执行程序的「入口」由两部分共同决定：

- 包名必须是 `main`；  
- 在这个包里必须声明一个 `main` 函数；  

只有同时满足这两点，这个包才能被编译成可执行程序，运行时从 `main` 函数开始执行。

一个最小可运行示例：

```go
package main

import "fmt"

func main() {
	fmt.Println("Hello, Go")
}
```

几个关键点：

- 包名 `main` 表示：这是一个可执行程序的入口包，而不是普通的库包；  
- `main` 函数是程序的起点，程序启动后会从这里开始执行；  
- `main` 函数的签名固定为 `func main()`，不能带参数，也不能有返回值；  

如果需要读取命令行参数，可以在 `main` 里通过 `os.Args` 获取，例如：

```go
package main

import (
	"fmt"
	"os"
)

func main() {
	fmt.Println(os.Args)
}
```

关于项目结构：

- 一个 Go 模块中可以有多个 `main` 包（例如 `cmd/server`、`cmd/worker` 等），每个目录下各自有一个 `main` 包和 `main` 函数；  
- 构建时指定不同目录，就会得到不同的可执行程序，例如：  
  - `go build ./cmd/server`  
  - `go build ./cmd/worker`  

普通库包（例如包名为 `user`、`service`、`util` 等）不会有 `main` 函数，它们只提供函数、类型等，被 `main` 包导入和调用：

```go
package main

import "example.com/project/user"

func main() {
	user.Run()
}
```

在程序启动顺序上，可以简单理解为：

- 编译器先根据依赖关系初始化各个包；  
- 每个包中的 `init` 函数（如果存在）会在 `main` 函数执行前运行；  
- 最后才进入 `main` 包的 `main` 函数，开始正式的业务逻辑；  

理解「main 包 + main 函数」这对组合，有助于你设计项目结构：把可执行入口放在 `cmd/xxx` 目录下，其他逻辑尽量做成可复用的库包，方便测试和复用。

## 热更新air安装与配置

在 Go 开发中，频繁修改代码后手动执行 `go run` 或 `go build` 再重启服务会比较麻烦。`air` 是一个常用的热重载工具，可以在检测到源码变更后自动完成：

- 重新编译项目；  
- 重启最新版本的可执行程序；  

### air 的基本使用流程

- 安装（Go 1.25 及以上推荐写法）：  
  - `go install github.com/air-verse/air@latest`  
- 确保 `$(go env GOPATH)/bin` 或 `$(go env GOBIN)` 在 `PATH` 中，这样终端里才能直接使用 `air` 命令；  
- 在项目根目录直接运行：  
  - `air`  
- 之后只要修改 `.go` 或模板文件并保存，`air` 就会根据配置自动重编译并重启程序。  

### .air.toml 配置说明

项目根目录下的 `.air.toml` 用来控制 air 的行为，你当前的配置大致含义如下：

- 顶层目录相关：  
  - `root = "."`：air 从当前目录作为项目根目录开始监视文件变更；  
  - `tmp_dir = "tmp"`：编译生成的临时文件会放在 `tmp` 目录中；  

- 构建与运行（`[build]`）：  
  - `cmd = "go build -o ./tmp/main ."`：检测到变更后执行的构建命令，生成二进制 `./tmp/main`；  
  - `bin = "./tmp/main"`：告诉 air 编译后的二进制路径；  
  - `entrypoint = ["./tmp/main"]`：构建成功后实际运行的命令，相当于直接执行生成的二进制；  
  - `delay = 1000`：文件变更后延迟 1000 毫秒再开始构建，避免频繁保存触发多次构建；  
  - `include_ext = ["go", "tpl", "tmpl", "html"]`：只要这些后缀的文件变化，就会触发重载；  
  - `exclude_dir = ["assets", "tmp", "vendor", "testdata"]`：这些目录不会被监听，其中 `tmp` 必须排除，避免因为编译输出本身变化导致无限重启；  
  - `exclude_regex = ["_test.go"]`：匹配 `_test.go` 的测试文件变更不会触发重载；  
  - `log = "build-errors.log"`：构建失败时的错误日志会写入这个文件，可以是相对路径（相对于项目根目录）或绝对路径，例如 `tmp/build-errors.log`。 

- 颜色和日志（`[color]`, `[log]`）：  
  - 控制 air 在终端输出的颜色，如构建日志用黄色，watcher 用青色等；  
  - 可以选择是否只输出主进程日志、是否加时间戳等，目前配置为正常输出、无时间戳；  

- 其他行为：  
  - `[screen]` 中 `clear_on_rebuild = false`：每次重建不会清空终端，可以保留历史输出；  
  - `[misc]` 中 `clean_on_exit = false`：退出 air 时不会自动删除 `tmp` 目录；  
  - `[proxy]` 目前关闭，表示不启用 HTTP 反向代理功能；  

整体来说，这份配置适合一个常规的 Go Web/API 项目开发场景：  

- 在项目根目录运行 `air`；  
- 浏览器或客户端连到你的服务端口；  
- 改 `.go` 或模板文件并保存后，等待 1 秒左右，服务会自动重启到最新版本，无需手动重复输入 `go run` 或 `go build`。  
